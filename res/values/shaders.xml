<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Common vertex shader for scene rendering -->
    <string name="shader_scene_vs">
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        attribute vec3 aColor;
        
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        void main() {
            gl_Position = uMVPMatrix * vec4(aPosition, 1.0);
            vNormal = vec3(uNormalMatrix * vec4(aNormal, 0.0));
            vPos = vec3(uMVMatrix * vec4(aPosition, 1.0));
            vColor = aColor;            
        }
    </string>
    <!-- Fragment shader for rendering Phong shaded scene -->
    <string name="shader_scene_phong_fs">
        precision mediump float;
        uniform vec3 uLights[4];
        uniform int uLightCount;
        uniform float uCocScale;
        uniform float uCocBias;
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        vec2 calcLight(vec3 N, vec3 lightDir, vec3 E) {
            vec2 lightVal = vec2(0.0);
            vec3 L = normalize(lightDir);
            
            float lambert = dot(N, L);
            if (lambert > 0.0) {
                float r = inversesqrt(length(lightDir));
                lightVal[0] = lambert * r;
                vec3 R = reflect(-L, N);
                lightVal[1] = pow(max(dot(R, E), 0.0), 8.0) * r;
            }
            return lightVal;
        }
        
        void main() {
            vec2 lightVal = vec2(0.0);
            vec3 N = normalize(vNormal);
            vec3 E = normalize(-vPos);
            if (uLightCount > 0)
                lightVal += calcLight(N, uLights[0] - vPos, E);
            if (uLightCount > 1)
                lightVal += calcLight(N, uLights[1] - vPos, E);
            if (uLightCount > 2)
                lightVal += calcLight(N, uLights[2] - vPos, E);
            if (uLightCount > 3)
                lightVal += calcLight(N, uLights[3] - vPos, E);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightVal[0], 1.0);
            float specular = min(lightVal[1], 1.0);
            
            const vec3 white = vec3(1.0);
            gl_FragColor.rgb = vColor * ambientPlusDiffuse;
            gl_FragColor.rgb = mix(gl_FragColor.rgb, white, specular);
            gl_FragColor.a = clamp(abs(gl_FragCoord.z * uCocScale + uCocBias), 0.0, 1.0);
            /* gl_FragColor.rgb = vec3(gl_FragColor.a); */
        }
    </string>
    <!-- Fragment shader for rendering Blinn-Phong shaded scene -->
    <string name="shader_scene_blinn_phong_fs">
        precision mediump float;
        uniform vec3 uLights[4];
        uniform int uLightCount;
        uniform float uCocScale;
        uniform float uCocBias;
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        vec2 calcLight(vec3 N, vec3 lightDir, vec3 E) {
            vec2 lightVal = vec2(0.0);
            vec3 L = normalize(lightDir);
            
            float lambert = dot(N, L);
            if (lambert > 0.0) {
                float r = inversesqrt(length(lightDir));
                lightVal[0] = lambert * r;
                vec3 HV = normalize(E + lightDir);
                lightVal[1] = pow(max(dot(HV, N), 0.0), 8.0) * r;
            }
            return lightVal;
        }
        
        void main() {
            vec2 lightVal = vec2(0.0);
            vec3 N = normalize(vNormal);
            vec3 E = normalize(-vPos);
            if (uLightCount > 0)
                lightVal += calcLight(N, uLights[0] - vPos, E);
            if (uLightCount > 1)
                lightVal += calcLight(N, uLights[1] - vPos, E);
            if (uLightCount > 2)
                lightVal += calcLight(N, uLights[2] - vPos, E);
            if (uLightCount > 3)
                lightVal += calcLight(N, uLights[3] - vPos, E);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightVal[0], 1.0);
            float specular = min(lightVal[1], 1.0);
            
            const vec3 white = vec3(1.0);
            gl_FragColor.rgb = vColor * ambientPlusDiffuse;
            gl_FragColor.rgb = mix(gl_FragColor.rgb, white, specular);
            gl_FragColor.a = clamp(abs(gl_FragCoord.z * uCocScale + uCocBias), 0.0, 1.0);
            /* gl_FragColor.rgb = vec3(gl_FragColor.a); */
        }
    </string>
    <!-- Vertex shader for rendering lights -->
    <string name="shader_light_vs">
        uniform mat4 uPMatrix;
        attribute vec3 aPosition;
        attribute vec2 aTexPosition;
        varying vec2 vTexPosition;
        
        void main() {
            gl_Position = uPMatrix * vec4(aPosition, 1.0);
            vTexPosition = aTexPosition;
        }
    </string>
    <!-- Fragment shader for rendering lights -->
    <string name="shader_light_fs">
        precision mediump float;
        varying vec2 vTexPosition;
        
        void main() {
            float dist = length(vTexPosition);
            gl_FragColor = vec4(1.0 - dist);
        }
    </string>
    <!-- General purpose vertex shader for texture filters -->
    <string name="shader_filter_vs">
        attribute vec4 aPosition;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_Position = aPosition;
            vTextureCoord = (gl_Position.xy + 1.0) * 0.5;
        }
    </string>
    <!-- Copy fragment shader -->
    <string name="shader_copy_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
        }
    </string>
    <!-- Displace fragment shader -->
    <string name="shader_displace_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec2 uPosition;
        uniform vec2 uDiff;
        varying vec2 vTextureCoord;
        
        void main() {
        	float c = 1.0 - sqrt(length(vTextureCoord - (uPosition - uDiff)));
            gl_FragColor = texture2D(sTexture0, vTextureCoord + c * uDiff);
        }
    </string>
    <!-- Input pass for bloom filter -->
    <string name="shader_bloom_pass1_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform float uThreshold;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            
            const vec3 perception = vec3(0.299, 0.587, 0.114);
            float luminance = dot(perception, gl_FragColor.rgb);
            luminance = (luminance - uThreshold) / (1.0 - uThreshold);
            gl_FragColor.a = clamp(luminance, 0.0, 1.0);
        }
    </string>
    <!-- Blur shader for bloom -->
    <string name="shader_bloom_pass2_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec2 uOffset;
        uniform float uSteps;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            vec2 offset = uOffset;
            gl_FragColor = vec4(0.0);
            for (float i = 0.0; i &lt; uSteps; ++i) {
                vec4 color0 = texture2D(sTexture0, vTextureCoord + offset);
                vec4 color1 = texture2D(sTexture0, vTextureCoord - offset);
                gl_FragColor.rgb += color0.rgb * color0.a;
                gl_FragColor.rgb += color1.rgb * color1.a;
                gl_FragColor.a += color0.a + color1.a;
                sum += 2.0;
                offset += uOffset;
            }
            gl_FragColor.rgb /= gl_FragColor.a;
            gl_FragColor.a /= sum;
        }
    </string>
    <!-- Output shader for bloom filter -->
    <string name="shader_bloom_pass3_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 color1 = texture2D(sTexture1, vTextureCoord);
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor.rgb += color1.rgb * color1.a;
        }
    </string>
    <!-- Input shader for lens blur filter -->
    <string name="shader_lensblur_pass1_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            const float minDivider = 1.0 / 255.0;
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor.a = mix(minDivider, 1.0, gl_FragColor.a);
            gl_FragColor.rgb *= gl_FragColor.a;
        }
    </string>
    <!-- Output shader for lens blur filter -->
    <string name="shader_lensblur_pass5_fs">
        precision mediump float;
        uniform sampler2D sTextureSrc;
        uniform sampler2D sTextureBokeh;
        uniform sampler2D sTextureBokehHdr;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 colSrc = texture2D(sTextureSrc, vTextureCoord);
            vec4 colBokeh = texture2D(sTextureBokeh, vTextureCoord);
            gl_FragColor = mix(colSrc, colBokeh, colBokeh.a);
            /*gl_FragColor.rgb += colBokehHdr.rgb * colBokehHdr.a;*/
        }
    </string>
    <!-- First blur pass for lens blur -->
    <string name="shader_lensblur_pass2_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord0 = vTextureCoord;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                if (sample0.a * uSteps >= t) {
                    float c = 1.0 - abs(sample0.a - coc);
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                textureCoord0 += uDelta0;
            }
            gl_FragColor /= sum;
        }
    </string>
    <!-- Second blur pass for lens blur -->
    <string name="shader_lensblur_pass3_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    float c = 1.0 - abs(sample0.a - coc);
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor += texture2D(sTexture1, vTextureCoord - uDelta1 * 0.5);
            gl_FragColor *= 0.5;
        }
    </string>
    <!-- Third pass for lens blur filter -->
    <string name="shader_lensblur_pass4_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            vec2 textureCoord0 = vTextureCoord;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            float coc0 = texture2D(sTexture0, textureCoord0).a;
            float coc1 = texture2D(sTexture1, textureCoord1).a;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; t++) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                vec4 sample1 = texture2D(sTexture1, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    float c = 2.0 * (1.0 - abs(sample0.a - coc0));
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                if (sample1.a * uSteps >= t) {
                    float c = 1.0 - abs(sample1.a - coc1);
                    gl_FragColor += sample1 * c;
                    sum += c;
                }
                textureCoord0 += uDelta0;
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor.rgb /= gl_FragColor.a;
        }
    </string>
    <!-- FXAA anti-alias filter fragment shader -->
    <string name="shader_fxaa_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec2 uRcpFrame;
        varying vec2 vTextureCoord;
        
        vec4 FxaaTexTop(vec2 pos) {
            vec4 color;
            color.rgb = texture2D(sTexture0, pos).rgb;
            color.a = sqrt(dot(color.rgb, vec3(0.299, 0.587, 0.114)));
            return color;
        }
        
        vec4 FxaaTexOff(vec2 pos, vec2 off, vec2 rcp) {
            return FxaaTexTop(pos + (off * rcp));
        }
        
        vec4 FxaaPixelShader(vec2 pos,
                             vec2 fxaaQualityRcpFrame,
                             float fxaaQualitySubpix,
                             float fxaaQualityEdgeThreshold,
                             float fxaaQualityEdgeThresholdMin) {
            vec2 posM;
            posM.x = pos.x;
            posM.y = pos.y;
            
            vec4 rgbyM = FxaaTexTop(posM);            
            float lumaM = rgbyM.w;
            
            float lumaS = FxaaTexOff(posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame).a;
            float lumaE = FxaaTexOff(posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame).a;
            float lumaN = FxaaTexOff(posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame).a;
            float lumaW = FxaaTexOff(posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame).a;
            
            float maxSM = max(lumaS, lumaM);
            float minSM = min(lumaS, lumaM);
            float maxESM = max(lumaE, maxSM);
            float minESM = min(lumaE, minSM);
            float maxWN = max(lumaN, lumaW);
            float minWN = min(lumaN, lumaW);
            float rangeMax = max(maxWN, maxESM);
            float rangeMin = min(minWN, minESM);
            float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
            float range = rangeMax - rangeMin;
            float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
            bool earlyExit = range &lt; rangeMaxClamped;
            
            if (earlyExit)
                return rgbyM;
            
            float lumaNW = FxaaTexOff(posM, vec2(-1.0,-1.0), fxaaQualityRcpFrame).a;
            float lumaSE = FxaaTexOff(posM, vec2( 1.0, 1.0), fxaaQualityRcpFrame).a;
            float lumaNE = FxaaTexOff(posM, vec2( 1.0,-1.0), fxaaQualityRcpFrame).a;
            float lumaSW = FxaaTexOff(posM, vec2(-1.0, 1.0), fxaaQualityRcpFrame).a;
            
            float lumaNS = lumaN + lumaS;
            float lumaWE = lumaW + lumaE;
            float subpixRcpRange = 1.0/range;
            float subpixNSWE = lumaNS + lumaWE;
            float edgeHorz1 = (-2.0 * lumaM) + lumaNS;
            float edgeVert1 = (-2.0 * lumaM) + lumaWE;
        
            float lumaNESE = lumaNE + lumaSE;
            float lumaNWNE = lumaNW + lumaNE;
            float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
            float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
            
            float lumaNWSW = lumaNW + lumaSW;
            float lumaSWSE = lumaSW + lumaSE;
            float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
            float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
            float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
            float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
            float edgeHorz = abs(edgeHorz3) + edgeHorz4;
            float edgeVert = abs(edgeVert3) + edgeVert4;
            
            float subpixNWSWNESE = lumaNWSW + lumaNESE;
            float lengthSign = fxaaQualityRcpFrame.x;
            bool horzSpan = edgeHorz >= edgeVert;
            float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
            float subpixB = (subpixA * (1.0 / 12.0)) - lumaM;
            
            if(!horzSpan) {
                lumaN = lumaW;
                lumaS = lumaE;
            } else {
                lengthSign = fxaaQualityRcpFrame.y;
            }
            
            float gradientN = lumaN - lumaM;
            float gradientS = lumaS - lumaM;
            float lumaNN = lumaN + lumaM;
            float lumaSS = lumaS + lumaM;
            bool pairN = abs(gradientN) >= abs(gradientS);
            float gradient = max(abs(gradientN), abs(gradientS));
            
            if (pairN)
                lengthSign = -lengthSign;
            
            float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);
            
            vec2 posB;
            posB.x = posM.x;
            posB.y = posM.y;
            vec2 offNP;
            offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
            offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
            
            if (!horzSpan)
                posB.x += lengthSign * 0.5;
            else
                posB.y += lengthSign * 0.5;
            
            const float FXAA_QUALITY_P0 = 1.0;
            const float FXAA_QUALITY_P1 = 1.5;
            const float FXAA_QUALITY_P2 = 2.0;
            const float FXAA_QUALITY_P3 = 2.0;
            const float FXAA_QUALITY_P4 = 2.0;
            const float FXAA_QUALITY_P5 = 2.0;
            const float FXAA_QUALITY_P6 = 4.0;
            const float FXAA_QUALITY_P7 = 8.0;
            
            vec2 posN;
            posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
            posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
            vec2 posP;
            posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
            posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
            float subpixD = ((-2.0)*subpixC) + 3.0;
            float lumaEndN = FxaaTexTop(posN).a;
            float subpixE = subpixC * subpixC;
            float lumaEndP = FxaaTexTop(posP).a;
            
            if (!pairN)
                lumaNN = lumaSS;
            
            float gradientScaled = gradient * 1.0 / 4.0;
            float lumaMM = lumaM - lumaNN * 0.5;
            float subpixF = subpixD * subpixE;
            bool lumaMLTZero = lumaMM &lt; 0.0;
            
            lumaEndN -= lumaNN * 0.5;
            lumaEndP -= lumaNN * 0.5;
            bool doneN = abs(lumaEndN) >= gradientScaled;
            bool doneP = abs(lumaEndP) >= gradientScaled;
            bool doneNP = (!doneN) || (!doneP);
            if (!doneN) {
                posN.x -= offNP.x * FXAA_QUALITY_P1;
                posN.y -= offNP.y * FXAA_QUALITY_P1;
            }
            if (!doneP) {
                posP.x += offNP.x * FXAA_QUALITY_P1;
                posP.y += offNP.y * FXAA_QUALITY_P1;
            }
            
            if (doneNP) {
                if (!doneN) lumaEndN = FxaaTexTop(posN.xy).a - lumaNN * 0.5;
                if (!doneP) lumaEndP = FxaaTexTop(posP.xy).a - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                doneNP = (!doneN) || (!doneP);
                if (!doneN) {
                    posN.x -= offNP.x * FXAA_QUALITY_P2;
                    posN.y -= offNP.y * FXAA_QUALITY_P2;
                }
                if (!doneP) {
                    posP.x += offNP.x * FXAA_QUALITY_P2;
                    posP.y += offNP.y * FXAA_QUALITY_P2;
                }
                
                if (doneNP) {
                    if (!doneN) lumaEndN = FxaaTexTop(posN.xy).a - lumaNN * 0.5;
                    if (!doneP) lumaEndP = FxaaTexTop(posP.xy).a - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    doneNP = (!doneN) || (!doneP);
                    if (!doneN) {
                        posN.x -= offNP.x * FXAA_QUALITY_P3;
                        posN.y -= offNP.y * FXAA_QUALITY_P3;
                    }
                    if (!doneP) {
                        posP.x += offNP.x * FXAA_QUALITY_P3;
                        posP.y += offNP.y * FXAA_QUALITY_P3;
                    }
        
                    if (doneNP) {
                    if (!doneN) lumaEndN = FxaaTexTop(posN.xy).a - lumaNN * 0.5;
                    if (!doneP) lumaEndP = FxaaTexTop(posP.xy).a - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        doneNP = (!doneN) || (!doneP);
                        if (!doneN) {
                            posN.x -= offNP.x * FXAA_QUALITY_P4;
                            posN.y -= offNP.y * FXAA_QUALITY_P4;
                        }
                        if (!doneP) {
                            posP.x += offNP.x * FXAA_QUALITY_P4;
                            posP.y += offNP.y * FXAA_QUALITY_P4;
                        }
                        
                        if (doneNP) {
                            if (!doneN) lumaEndN = FxaaTexTop(posN.xy).a - lumaNN * 0.5;
                            if (!doneP) lumaEndP = FxaaTexTop(posP.xy).a - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            doneNP = (!doneN) || (!doneP);
                            if (!doneN) {
                                posN.x -= offNP.x * FXAA_QUALITY_P5;
                                posN.y -= offNP.y * FXAA_QUALITY_P5;
                            }
                            if (!doneP) {
                                posP.x += offNP.x * FXAA_QUALITY_P5;
                                posP.y += offNP.y * FXAA_QUALITY_P5;
                            }
                            
                            if (doneNP) {
                                if (!doneN) lumaEndN = FxaaTexTop(posN.xy).a - lumaNN * 0.5;
                                if (!doneP) lumaEndP = FxaaTexTop(posP.xy).a - lumaNN * 0.5;
                                doneN = abs(lumaEndN) >= gradientScaled;
                                doneP = abs(lumaEndP) >= gradientScaled;
                                doneNP = (!doneN) || (!doneP);
                                if (!doneN) {
                                    posN.x -= offNP.x * FXAA_QUALITY_P6;
                                    posN.y -= offNP.y * FXAA_QUALITY_P6;
                                }
                                if (!doneP) {
                                    posP.x += offNP.x * FXAA_QUALITY_P6;
                                    posP.y += offNP.y * FXAA_QUALITY_P6;
                                }
                                
                                if (doneNP) {
                                    if (!doneN) lumaEndN = FxaaTexTop(posN.xy).a - lumaNN * 0.5;
                                    if (!doneP) lumaEndP = FxaaTexTop(posP.xy).a - lumaNN * 0.5;
                                    doneN = abs(lumaEndN) >= gradientScaled;
                                    doneP = abs(lumaEndP) >= gradientScaled;
                                    doneNP = (!doneN) || (!doneP);
                                    if (!doneN) {
                                        posN.x -= offNP.x * FXAA_QUALITY_P7;
                                        posN.y -= offNP.y * FXAA_QUALITY_P7;
                                    }
                                    if (!doneP) {
                                        posP.x += offNP.x * FXAA_QUALITY_P7;
                                        posP.y += offNP.y * FXAA_QUALITY_P7;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            float dstN = posM.x - posN.x;
            float dstP = posP.x - posM.x;
            
            if (!horzSpan) {
                dstN = posM.y - posN.y;
                dstP = posP.y - posM.y;
            }
            
            bool goodSpanN = (lumaEndN &lt; 0.0) != lumaMLTZero;
            float spanLength = (dstP + dstN);
            bool goodSpanP = (lumaEndP &lt; 0.0) != lumaMLTZero;
            float spanLengthRcp = 1.0/spanLength;
            
            bool directionN = dstN &lt; dstP;
            float dst = min(dstN, dstP);
            bool goodSpan = directionN ? goodSpanN : goodSpanP;
            float subpixG = subpixF * subpixF;
            float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
            float subpixH = subpixG * fxaaQualitySubpix;
            
            float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
            float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
            
            if (!horzSpan)
                posM.x += pixelOffsetSubpix * lengthSign;
            else 
                posM.y += pixelOffsetSubpix * lengthSign;
            
            return vec4(FxaaTexTop(posM).xyz, lumaM);
        }
        
        void main() {
            gl_FragColor = FxaaPixelShader(vTextureCoord, uRcpFrame,
                                           0.75, 0.166, 0.0833);
        }
    </string>

</resources>