<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Common vertex shader for scene rendering -->
    <string name="shader_scene_vs">
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        attribute vec3 aColor;
        
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        void main() {
            gl_Position = uMVPMatrix * vec4(aPosition, 1.0);
            vNormal = vec3(uNormalMatrix * vec4(aNormal, 0.0));
            vPos = vec3(uMVMatrix * vec4(aPosition, 1.0));
            vColor = aColor;            
        }
    </string>
    <!-- Fragment shader for rendering Phong shaded scene -->
    <string name="shader_scene_phong_fs">
        precision mediump float;
        uniform vec3 uLights[4];
        uniform int uLightCount;
        uniform float uAperture;
        uniform float uFocalLength;
        uniform float uPlaneInFocus;
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        vec2 calcLight(vec3 N, vec3 lightDir, vec3 E) {
            vec2 lightVal = vec2(0.0);
            vec3 L = normalize(lightDir);
            
            float lambert = dot(N, L);
            if (lambert > 0.0) {
                float r = inversesqrt(length(lightDir));
                lightVal[0] = lambert * r;
                vec3 R = reflect(-L, N);
                lightVal[1] = pow(max(dot(R, E), 0.0), 8.0) * r;
            }
            return lightVal;
        }
        
        void main() {
            vec2 lightVal = vec2(0.0);
            vec3 N = normalize(vNormal);
            vec3 E = normalize(-vPos);
            if (uLightCount > 0)
                lightVal += calcLight(N, uLights[0] - vPos, E);
            if (uLightCount > 1)
                lightVal += calcLight(N, uLights[1] - vPos, E);
            if (uLightCount > 2)
                lightVal += calcLight(N, uLights[2] - vPos, E);
            if (uLightCount > 3)
                lightVal += calcLight(N, uLights[3] - vPos, E);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightVal[0], 1.0);
            float specular = min(lightVal[1], 2.0);
            
            gl_FragColor.rgb = vColor * (ambientPlusDiffuse + specular);
            gl_FragColor.rgb /= 3.0;
            gl_FragColor.a = abs(uAperture * (uFocalLength * (vPos.z - uPlaneInFocus)) /
                                 (vPos.z * (uPlaneInFocus - uFocalLength)));
            /* gl_FragColor.rgb = vec3(gl_FragColor.a / 3.0); */
        }
    </string>
    <!-- Fragment shader for rendering Blinn-Phong shaded scene -->
    <string name="shader_scene_blinn_phong_fs">
        precision mediump float;
        uniform vec3 uLights[4];
        uniform int uLightCount;
        uniform float uAperture;
        uniform float uFocalLength;
        uniform float uPlaneInFocus;
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        vec2 calcLight(vec3 N, vec3 lightDir, vec3 E) {
            vec2 lightVal = vec2(0.0);
            vec3 L = normalize(lightDir);
            
            float lambert = dot(N, L);
            if (lambert > 0.0) {
                float r = inversesqrt(length(lightDir));
                lightVal[0] = lambert * r;
                vec3 HV = normalize(E + lightDir);
                lightVal[1] = pow(max(dot(HV, N), 0.0), 8.0) * r;
            }
            return lightVal;
        }
        
        void main() {
            vec2 lightVal = vec2(0.0);
            vec3 N = normalize(vNormal);
            vec3 E = normalize(-vPos);
            if (uLightCount > 0)
                lightVal += calcLight(N, uLights[0] - vPos, E);
            if (uLightCount > 1)
                lightVal += calcLight(N, uLights[1] - vPos, E);
            if (uLightCount > 2)
                lightVal += calcLight(N, uLights[2] - vPos, E);
            if (uLightCount > 3)
                lightVal += calcLight(N, uLights[3] - vPos, E);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightVal[0], 1.0);
            float specular = min(lightVal[1], 2.0);
            
            gl_FragColor.rgb = vColor * (ambientPlusDiffuse + specular);
            gl_FragColor.rgb /= 3.0;
            gl_FragColor.a = abs(uAperture * (uFocalLength * (vPos.z - uPlaneInFocus)) /
                                 (vPos.z * (uPlaneInFocus - uFocalLength)));
            /* gl_FragColor.rgb = vec3(gl_FragColor.a / 3.0); */
        }
    </string>
    <!-- Vertex shader for rendering lights -->
    <string name="shader_light_vs">
        uniform mat4 uPMatrix;
        uniform float uPointRadius;
        uniform float uViewWidth;
        attribute vec3 aPosition;
        varying float vZ;
        
        void main() {
            gl_Position = uPMatrix * vec4(aPosition, 1.0);
            vec4 pt = uPMatrix * vec4(uPointRadius, aPosition.yz, 1.0);
            gl_PointSize = max(4.0, uViewWidth * (pt.x / pt.w));
            vZ = aPosition.z;
        }
    </string>
    <!-- Fragment shader for rendering lights -->
    <string name="shader_light_fs">
        precision mediump float;
        uniform float uAperture;
        uniform float uFocalLength;
        uniform float uPlaneInFocus;
        varying float vZ;
        void main() {
            float dist = length(gl_PointCoord - 0.5);
            if (dist > 0.5)
                discard;
            gl_FragColor.rgb = vec3(1.0 - dist);
            gl_FragColor.a = abs(uAperture * (uFocalLength * (vZ - uPlaneInFocus)) /
                                 (vZ * (uPlaneInFocus - uFocalLength)));
        }
    </string>
    <!-- General purpose vertex shader for 2D texture filters -->
    <string name="shader_filter_vs">
        attribute vec4 aPosition;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_Position = aPosition;
            vTextureCoord = (gl_Position.xy + 1.0) * 0.5;
        }
    </string>
    <!-- Copy fragment shader -->
    <string name="shader_copy_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor *= 3.0;
        }
    </string>
    <!-- Displace fragment shader -->
    <string name="shader_displace_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec2 uPosition;
        uniform vec2 uDiff;
        varying vec2 vTextureCoord;
        
        void main() {
        	float c = 1.0 - sqrt(length(vTextureCoord - (uPosition - uDiff)));
            gl_FragColor = texture2D(sTexture0, vTextureCoord + c * uDiff);
            gl_FragColor *= 3.0;
        }
    </string>
    <!-- Input pass for bloom filter -->
    <string name="shader_bloom_pass1_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor *= 1.5;
            gl_FragColor -= 0.5;
        }
    </string>
    <!-- Blur shader for bloom -->
    <string name="shader_bloom_pass2_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec3 uIncrementalGaussian;
        uniform vec2 uBlurOffset;
        uniform float uNumBlurPixelsPerSide;
        varying vec2 vTextureCoord;
        
        void main() {
            vec3 incrementalGaussian = uIncrementalGaussian;            
            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            float coefficientSum = 0.0;
            
            gl_FragColor += texture2D(sTexture0, vTextureCoord) * incrementalGaussian.x;
            coefficientSum += incrementalGaussian.x;
            incrementalGaussian.xy *= incrementalGaussian.yz;
            
            vec2 blurOffset = uBlurOffset;
            
            for (float i = 1.0; i &lt;= uNumBlurPixelsPerSide; i++) {
                gl_FragColor += texture2D(sTexture0, vTextureCoord - blurOffset) * incrementalGaussian.x;
                gl_FragColor += texture2D(sTexture0, vTextureCoord + blurOffset) * incrementalGaussian.x;
                coefficientSum += 2.0 * incrementalGaussian.x;
                incrementalGaussian.xy *= incrementalGaussian.yz;
                blurOffset += uBlurOffset;
            }
            
            gl_FragColor /= coefficientSum;
        }
    </string>
    <!-- Output shader for bloom filter -->
    <string name="shader_bloom_pass3_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 color0 = texture2D(sTexture0, vTextureCoord);
            vec4 color1 = texture2D(sTexture1, vTextureCoord);
            gl_FragColor = color0  + color1;
        }
    </string>
    <!-- Input shader for lens blur filter -->
    <string name="shader_lensblur_pass1_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            const float minDivider = 1.0 / 255.0;
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor.a = mix(minDivider, 1.0, gl_FragColor.a);
            gl_FragColor.rgb *= gl_FragColor.a;
        }
    </string>
    <!-- Output shader for lens blur filter -->
    <string name="shader_lensblur_pass5_fs">
        precision mediump float;
        uniform sampler2D sTextureSrc;
        uniform sampler2D sTextureBokeh;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 colSrc = texture2D(sTextureSrc, vTextureCoord);
            vec4 colBokeh = texture2D(sTextureBokeh, vTextureCoord);
            gl_FragColor = mix(colSrc, colBokeh, colBokeh.a);
        }
    </string>
    <!-- First blur pass for lens blur -->
    <string name="shader_lensblur_pass2_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord0 = vTextureCoord;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                if (sample0.a * uSteps >= t) {
                    if (coc * uSteps >= t) {
                        gl_FragColor += sample0;
                        sum += 1.0;
                    }
                }
                textureCoord0 += uDelta0;
            }
            gl_FragColor /= sum;
        }
    </string>
    <!-- Second blur pass for lens blur -->
    <string name="shader_lensblur_pass3_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    if (coc * uSteps >= t) {
                        gl_FragColor += sample0;
                        sum += 1.0;
                   }
                 }
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor += texture2D(sTexture1, vTextureCoord - uDelta1 * 0.5);
            gl_FragColor *= 0.5;
        }
    </string>
    <!-- Third pass for lens blur filter -->
    <string name="shader_lensblur_pass4_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            vec2 textureCoord0 = vTextureCoord;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            float coc0 = texture2D(sTexture0, textureCoord0).a;
            float coc1 = texture2D(sTexture1, textureCoord1).a;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; t++) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                vec4 sample1 = texture2D(sTexture1, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    if (coc0 * uSteps >= t) {
                        gl_FragColor += 2.0 * sample0;
                        sum += 2.0;
                    }
                }
                if (sample1.a * uSteps >= t) {
                    if (coc1 * uSteps >= t) {
                        gl_FragColor += sample1;
                        sum += 1.0;
                    }
                }
                textureCoord0 += uDelta0;
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor.rgb /= gl_FragColor.a;
        }
    </string>
    <!-- FXAA anti-alias filter fragment shader -->
    <string name="shader_fxaa_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec4 uFxaaConsoleRcpFrameOpt;
        uniform vec4 uFxaaConsoleRcpFrameOpt2;
        uniform vec4 uFrameSize;
        varying vec2 vTextureCoord;
        
        vec4 FxaaTexTop(vec2 pos) {
            vec4 color;
            color.rgb = texture2D(sTexture0, pos).rgb;
            color.a = sqrt(dot(color.rgb, vec3(0.299, 0.587, 0.114)));
            return color;
        }
        
        /* PC console FXAA implementation */
        vec4 FxaaPixelShader(vec2 pos,
                             vec4 fxaaConsolePosPos,
                             vec4 fxaaConsoleRcpFrameOpt,
                             vec4 fxaaConsoleRcpFrameOpt2,
                             float fxaaConsoleEdgeSharpness,
                             float fxaaConsoleEdgeThreshold,
                             float fxaaConsoleEdgeThresholdMin) {
            float lumaNw = FxaaTexTop(fxaaConsolePosPos.xy).a;
            float lumaSw = FxaaTexTop(fxaaConsolePosPos.xw).a;
            float lumaNe = FxaaTexTop(fxaaConsolePosPos.zy).a;
            float lumaSe = FxaaTexTop(fxaaConsolePosPos.zw).a;
            
            vec4 rgbyM = FxaaTexTop(pos.xy);
            float lumaM = rgbyM.w;
            
            float lumaMaxNwSw = max(lumaNw, lumaSw);
            lumaNe += 1.0/384.0;
            float lumaMinNwSw = min(lumaNw, lumaSw);
            
            float lumaMaxNeSe = max(lumaNe, lumaSe);
            float lumaMinNeSe = min(lumaNe, lumaSe);
            
            float lumaMax = max(lumaMaxNeSe, lumaMaxNwSw);
            float lumaMin = min(lumaMinNeSe, lumaMinNwSw);
            
            float lumaMaxScaled = lumaMax * fxaaConsoleEdgeThreshold;

            float lumaMinM = min(lumaMin, lumaM);
            float lumaMaxScaledClamped = max(fxaaConsoleEdgeThresholdMin, lumaMaxScaled);
            float lumaMaxM = max(lumaMax, lumaM);
            float dirSwMinusNe = lumaSw - lumaNe;
            float lumaMaxSubMinM = lumaMaxM - lumaMinM;
            float dirSeMinusNw = lumaSe - lumaNw;
            
            if (lumaMaxSubMinM &lt; lumaMaxScaledClamped)
                return rgbyM;
            
            vec2 dir;
            dir.x = dirSwMinusNe + dirSeMinusNw;
            dir.y = dirSwMinusNe - dirSeMinusNw;
            
            vec2 dir1 = normalize(dir.xy);
            vec4 rgbyN1 = FxaaTexTop(pos.xy - dir1 * fxaaConsoleRcpFrameOpt.zw);
            vec4 rgbyP1 = FxaaTexTop(pos.xy + dir1 * fxaaConsoleRcpFrameOpt.zw);
            
            float dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * fxaaConsoleEdgeSharpness;
            vec2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);
            
            vec4 rgbyN2 = FxaaTexTop(pos.xy - dir2 * fxaaConsoleRcpFrameOpt2.zw);
            vec4 rgbyP2 = FxaaTexTop(pos.xy + dir2 * fxaaConsoleRcpFrameOpt2.zw);
            
            vec4 rgbyA = rgbyN1 + rgbyP1;
            vec4 rgbyB = ((rgbyN2 + rgbyP2) * 0.25) + (rgbyA * 0.25);
            
            bool twoTap = (rgbyB.w &lt; lumaMin) || (rgbyB.w > lumaMax);
            if (twoTap)
                rgbyB.xyz = rgbyA.xyz * 0.5;
            
            return rgbyB;
        }
        
        void main() {
            /* uFrameSize.xy = width, height
               uFrameSize.zw = 1/width, 1/height */
            vec4 fxaaConsolePosPos;
            fxaaConsolePosPos.xy = floor(vTextureCoord * uFrameSize.xy);
            fxaaConsolePosPos.zw = fxaaConsolePosPos.xy + 1.0;
            fxaaConsolePosPos *= uFrameSize.zwzw;
            
            const float fxaaConsoleEdgeSharpness = 4.0;
            const float fxaaConsoleEdgeThreshold = 0.125;
            const float fxaaConsoleEdgeThresholdMin = 0.05;            
            
            gl_FragColor = FxaaPixelShader(vTextureCoord,
                                           fxaaConsolePosPos,
                                           uFxaaConsoleRcpFrameOpt,
                                           uFxaaConsoleRcpFrameOpt2,
                                           fxaaConsoleEdgeSharpness,
                                           fxaaConsoleEdgeThreshold,
                                           fxaaConsoleEdgeThresholdMin);
        }
    </string>

</resources>