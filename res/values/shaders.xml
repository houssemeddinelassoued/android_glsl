<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="shader_scene_vs">
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        uniform vec4 uLights[4];
        uniform lowp int uLightCount;
        
        attribute vec4 aPosition;
        attribute vec4 aNormal;
        attribute vec4 aColor;
        
        varying vec4 vPos;
        varying vec4 vNormal;
        varying vec4 vColor;
        varying vec4 vEyeVec;
        varying vec4 vLights[4];
        
        vec4 calcLight(vec4 lightPos, vec4 vertexPos) {
            vec4 light = vec4(lightPos - vertexPos);
            float dist = length(light.xyz);
            light.w = inversesqrt(dist);
            return light;
        }
        
        void main() {
            gl_Position = uMVPMatrix * aPosition;            
            vPos = gl_Position;
            vPos.xy *= 0.5;
            vec4 mvPos = uMVMatrix * aPosition;
            vNormal = vec4((uNormalMatrix * aNormal).xyz, 0.0);
            vColor = aColor;
            vEyeVec = vec4(-(mvPos.xyz), 0.0);
            
            if (uLightCount > 0)
                vLights[0] = calcLight(uLights[0], mvPos);
            if (uLightCount > 1)
                vLights[1] = calcLight(uLights[1], mvPos);
            if (uLightCount > 2)
                vLights[2] = calcLight(uLights[2], mvPos);
            if (uLightCount > 3)
                vLights[3] = calcLight(uLights[3], mvPos);
        }
    </string>
    <string name="shader_scene_fs">
        precision mediump float;
        uniform lowp int uLightCount;
        varying vec4 vPos;
        varying vec4 vNormal;
        varying vec4 vColor;
        varying vec4 vEyeVec;
        varying vec4 vLights[4];
        
        vec2 calcLight(vec4 normal, vec4 lightDir, vec4 eyeVec) {
            vec2 lightning = vec2(0.0);
            vec4 lightNormal = vec4(normalize(lightDir.xyz), 0.0);
            
            float lambert = dot(normal, lightNormal);
            if (lambert > 0.0) {
                lightning.x = lambert * lightDir.w;
                vec4 reflection = reflect(-lightNormal, normal);
                lightning.y = pow(max(dot(reflection, eyeVec), 0.0), 3.0) * lightDir.w;
            }
            return lightning;
        }
        
        void main() {
            vec2 pos = (vPos.xy / vPos.w) + 0.5;
            vec4 normal = normalize(vNormal);
            vec4 eyeVec = normalize(vEyeVec);
            
            vec2 lightning = vec2(0.0);
            if (uLightCount > 0)
                lightning += calcLight(normal, vLights[0], eyeVec);
            if (uLightCount > 1)
                lightning += calcLight(normal, vLights[1], eyeVec);
            if (uLightCount > 2)
                lightning += calcLight(normal, vLights[2], eyeVec);
            if (uLightCount > 3)
                lightning += calcLight(normal, vLights[3], eyeVec);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightning.x, 1.0);
            float specular = min(lightning.y, 1.0);
            
            const vec4 white = vec4(1.0);
            gl_FragColor = vColor * ambientPlusDiffuse;
			gl_FragColor = mix(gl_FragColor, white, specular);
			gl_FragColor.a = vPos.z / vPos.w;
        }
    </string>
    <string name="shader_filter_vs">
        attribute vec4 aPosition;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_Position = aPosition;
            vTextureCoord = (gl_Position.xy + 1.0) * 0.5;
        }
    </string>
    <string name="shader_lensblur_in_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            
            float A = 3.0;
            float fLen = 2.0;
            float fPlane = 20.0;
            float zNear = 1.0;
            float zFar = 20.0;
            
            float cocScale = (A * fLen * fPlane * (zFar- zNear)) / ((fPlane - fLen) * zNear *zFar);
            float cocBias = (A * fLen * (zNear - fPlane)) / ((fPlane + fLen) * zNear);
            
            const float minDivider = 1.0 / 255.0;
            gl_FragColor.a = min(abs(gl_FragColor.a * cocScale + cocBias), 1.0);
            gl_FragColor.rgb *= mix(minDivider, 1.0, gl_FragColor.a);
        }
    </string>
    <string name="shader_lensblur_out_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 colSrc0 = texture2D(sTexture0, vTextureCoord);
            const float minDivider = 1.0 / 255.0;
            colSrc0.rgb /= mix(minDivider, 1.0, colSrc0.a);
            vec4 colSrc1 = texture2D(sTexture1, vTextureCoord);
            gl_FragColor = mix(colSrc1, colSrc0, colSrc0.a);
        }
    </string>
    <string name="shader_lensblur_1_fs">
        precision mediump float;
        uniform int uSteps;
        uniform sampler2D sTexture0;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = vec4(0.0);
            float coc0 = texture2D(sTexture0, vTextureCoord).a;
            
            float weightSum = 0.0;            
            vec2 delta0 = vec2(uDelta0) * (coc0 / float(uSteps));
            vec2 textureCoord0 = vTextureCoord + delta0 * 0.5;
            vec4 color0;
            for (int t = 0; t &lt;= uSteps; ++t) {
                color0 = texture2D(sTexture0, textureCoord0);
                gl_FragColor += color0 * color0.a;
                weightSum += color0.a;
                textureCoord0 += delta0;
            }
            if (weightSum > 0.0) {
                gl_FragColor /= weightSum;
            }
        }
    </string>
    <string name="shader_lensblur_2_fs">
        precision mediump float;
        uniform int uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = vec4(0.0);
            float coc0 = texture2D(sTexture0, vTextureCoord).a;
            
            float weightSum = 0.0;            
            vec2 delta0 = vec2(uDelta0) * (coc0 / float(uSteps));
            vec2 textureCoord0 = vTextureCoord + delta0 * 0.5;
            vec4 color0;
            for (int t = 0; t &lt;= uSteps; ++t) {
                color0 = texture2D(sTexture0, textureCoord0);
                gl_FragColor += color0 * color0.a;
                weightSum += color0.a;
                textureCoord0 += delta0;
            }
            if (weightSum > 0.0) {
                gl_FragColor /= weightSum;
            }
            gl_FragColor = (gl_FragColor + texture2D(sTexture1, vTextureCoord)) * 0.5;
        }
    </string>
    <string name="shader_lensblur_3_fs">
        precision mediump float;
        uniform int uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = vec4(0.0);
            float coc0 = texture2D(sTexture0, vTextureCoord).a;
            float coc1 = texture2D(sTexture1, vTextureCoord).a;
            
            float weightSum = 0.0;            
            vec2 delta0 = vec2(uDelta0) * (coc0 / float(uSteps));
            vec2 delta1 = vec2(uDelta1) * (coc1 / float(uSteps));
            vec2 textureCoord0 = vTextureCoord + delta0 * 0.5;
            vec2 textureCoord1 = vTextureCoord + delta1 * 0.5;
            
            vec4 color0, color1;
            for (int t = 0; t &lt;= uSteps; ++t) {
                color0 = texture2D(sTexture0, textureCoord0);
                gl_FragColor += color0 * color0.a;
                weightSum += color0.a;
                textureCoord0 += delta0;
                
                color1 = texture2D(sTexture1, textureCoord1);
                gl_FragColor += color1 * color1.a;
                weightSum += color1.a;
                textureCoord1 += delta1;
            }
            if (weightSum > 0.0) {
                gl_FragColor /= weightSum;
            }
        }
    </string>
    <string name="shader_copy_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
        }
    </string>

</resources>