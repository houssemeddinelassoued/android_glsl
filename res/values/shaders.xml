<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="shader_scene_vs">
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        
        attribute vec4 aPosition;
        attribute vec4 aNormal;
        attribute vec4 aColor;
        
        varying vec4 vPos;
        varying vec4 vMvPos;
        varying vec4 vNormal;
        varying vec4 vColor;
        
        void main() {
            gl_Position = uMVPMatrix * vec4(aPosition.xyz, 1.0);
            vPos = gl_Position;
            vPos.xy *= 0.5;
            vMvPos = uMVMatrix * aPosition, 1.0;
            vMvPos.w = 0.0;
            vNormal = uNormalMatrix * aNormal;
            vNormal.w = 0.0;
            vNormal.xyz *= 1.0 / length(vNormal);
            vColor = aColor;
        }
    </string>
    <string name="shader_scene_fs">
        precision mediump float;
        uniform vec4 uLights[4];
        uniform int uLightCount;
        uniform float uCocScale;
        uniform float uCocBias;
        varying vec4 vPos;
        varying vec4 vMvPos;
        varying vec4 vNormal;
        varying vec4 vColor;
        
        vec2 calcLight(vec4 normal, vec4 lightDir, vec4 eyeVec) {
            vec2 lightVal = vec2(0.0);
            vec4 lightNormal = vec4(normalize(lightDir.xyz), 0.0);
            
            float lambert = dot(normal, lightNormal);
            if (lambert > 0.0) {
                float corr = inversesqrt(length(lightDir.xyz));
                lightVal[0] = lambert * corr;
                vec4 reflection = reflect(-lightNormal, normal);
                lightVal[1] = pow(max(dot(reflection, eyeVec), 0.0), 8.0) * corr;
            }
            return lightVal;
        }
        
        void main() {
            vec2 pos = (vPos.xy / vPos.w) + 0.5;
            
            vec2 lightVal = vec2(0.0);
            vec4 normal = normalize(vNormal);
            vec4 eyeVec = normalize(-vMvPos);
            if (uLightCount > 0)
                lightVal += calcLight(normal, uLights[0] - vMvPos, eyeVec);
            if (uLightCount > 1)
                lightVal += calcLight(normal, uLights[1] - vMvPos, eyeVec);
            if (uLightCount > 2)
                lightVal += calcLight(normal, uLights[2] - vMvPos, eyeVec);
            if (uLightCount > 3)
                lightVal += calcLight(normal, uLights[3] - vMvPos, eyeVec);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightVal[0], 1.0);
            float specular = min(lightVal[1], 1.0);
            
            const vec4 white = vec4(1.0);
            gl_FragColor = vColor * ambientPlusDiffuse;
            gl_FragColor = mix(gl_FragColor, white, specular);
            gl_FragColor.a = clamp(abs(gl_FragCoord.z * uCocScale + uCocBias), 0.0, 1.0);
            /* gl_FragColor.rgb = vec3(gl_FragColor.a); */
        }
    </string>
    <string name="shader_filter_vs">
        attribute vec4 aPosition;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_Position = aPosition;
            vTextureCoord = (gl_Position.xy + 1.0) * 0.5;
        }
    </string>
    <string name="shader_lensblur_in_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            const float minDivider = 1.0 / 255.0;
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor.a = mix(minDivider, 1.0, gl_FragColor.a);
            gl_FragColor.rgb *= gl_FragColor.a;
        }
    </string>
    <string name="shader_lensblur_out_fs">
        precision mediump float;
        uniform sampler2D sTextureSrc;
        uniform sampler2D sTextureBokeh;
        uniform sampler2D sTextureBokehHdr;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 colSrc = texture2D(sTextureSrc, vTextureCoord);
            vec4 colBokeh = texture2D(sTextureBokeh, vTextureCoord);
            vec4 colBokehHdr = texture2D(sTextureBokehHdr, vTextureCoord);
            
            gl_FragColor = mix(colSrc, colBokeh, colBokeh.a);
            /*gl_FragColor.rgb += colBokehHdr.rgb * min(0.5, pow(colBokehHdr.a, 1.0 / 4.0));*/
        }
    </string>
    <string name="shader_lensblur_hdr_in_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            const float minDivider = 1.0 / 255.0;
            const float threshold = 0.3;
            const vec3 perception = vec3(0.299, 0.587, 0.114);
            
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            
            float luminance = dot(perception, gl_FragColor.rgb);
            if (luminance &lt; threshold)
                gl_FragColor.rgb = vec3(0.0);
            
            gl_FragColor.a = mix(minDivider, 1.0, gl_FragColor.a);
            gl_FragColor.rgb *= gl_FragColor.a;
        }
    </string>
    <string name="shader_lensblur_1_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord0 = vTextureCoord;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                if (sample0.a * uSteps >= t) {
                    float c = 1.0 - abs(sample0.a - coc);
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                textureCoord0 += uDelta0;
            }
            gl_FragColor /= sum;
        }
    </string>
    <string name="shader_lensblur_2_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    float c = 1.0 - abs(sample0.a - coc);
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor += texture2D(sTexture1, vTextureCoord - uDelta1 * 0.5);
            gl_FragColor *= 0.5;
        }
    </string>
    <string name="shader_lensblur_3_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            vec2 textureCoord0 = vTextureCoord;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            float coc0 = texture2D(sTexture0, textureCoord0).a;
            float coc1 = texture2D(sTexture1, textureCoord1).a;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; t++) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                vec4 sample1 = texture2D(sTexture1, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    float c = 2.0 * (1.0 - abs(sample0.a - coc0));
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                if (sample1.a * uSteps >= t) {
                    float c = 1.0 - abs(sample1.a - coc1);
                    gl_FragColor += sample1 * c;
                    sum += c;
                }
                textureCoord0 += uDelta0;
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor.rgb /= gl_FragColor.a;
        }
    </string>
    <string name="shader_copy_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
        }
    </string>

</resources>