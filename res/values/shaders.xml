<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Vertex shader for rendering Phong shaded scene -->
    <string name="shader_scene_phong_vs">
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        attribute vec3 aColor;
        
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        void main() {
            gl_Position = uMVPMatrix * vec4(aPosition, 1.0);
            vNormal = vec3(uNormalMatrix * vec4(aNormal, 0.0));
            vPos = vec3(uMVMatrix * vec4(aPosition, 1.0));
            vColor = aColor;
        }
    </string>
    <!-- Fragment shader for rendering Phong shaded scene -->
    <string name="shader_scene_phong_fs">
        precision mediump float;
        uniform vec3 uLights[4];
        uniform int uLightCount;
        uniform float uCocScale;
        uniform float uCocBias;
        varying vec3 vPos;
        varying vec3 vNormal;
        varying vec3 vColor;
        
        vec2 calcLight(vec3 N, vec3 lightDir, vec3 E) {
            vec2 lightVal = vec2(0.0);
            vec3 L = normalize(lightDir);
            
            float lambert = dot(N, L);
            if (lambert > 0.0) {
                float r = inversesqrt(length(lightDir));
                lightVal[0] = lambert * r;
                vec3 R = reflect(-L, N);
                lightVal[1] = pow(max(dot(R, E), 0.0), 8.0) * r;
            }
            return lightVal;
        }
        
        void main() {
            vec2 lightVal = vec2(0.0);
            vec3 N = normalize(vNormal);
            vec3 E = normalize(-vPos);
            if (uLightCount > 0)
                lightVal += calcLight(N, uLights[0] - vPos, E);
            if (uLightCount > 1)
                lightVal += calcLight(N, uLights[1] - vPos, E);
            if (uLightCount > 2)
                lightVal += calcLight(N, uLights[2] - vPos, E);
            if (uLightCount > 3)
                lightVal += calcLight(N, uLights[3] - vPos, E);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightVal[0], 1.0);
            float specular = min(lightVal[1], 1.0);
            
            const vec3 white = vec3(1.0);
            gl_FragColor.rgb = vColor * ambientPlusDiffuse;
            gl_FragColor.rgb = mix(gl_FragColor.rgb, white, specular);
            gl_FragColor.a = clamp(abs(gl_FragCoord.z * uCocScale + uCocBias), 0.0, 1.0);
            /* gl_FragColor.rgb = vec3(gl_FragColor.a); */
        }
    </string>
    <!-- Vertex shader for rendering lights -->
    <string name="shader_light_vs">
        uniform mat4 uPMatrix;
        attribute vec3 aPosition;
        attribute vec2 aTexPosition;
        varying vec2 vTexPosition;
        
        void main() {
            gl_Position = uPMatrix * vec4(aPosition, 1.0);
            vTexPosition = aTexPosition;
        }
    </string>
    <!-- Fragment shader for rendering lights -->
    <string name="shader_light_fs">
        precision mediump float;
        varying vec2 vTexPosition;
        
        void main() {
            float dist = length(vTexPosition);
            gl_FragColor = vec4(1.0 - dist);
        }
    </string>
    <!-- General purpose vertex shader for texture filters -->
    <string name="shader_filter_vs">
        attribute vec4 aPosition;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_Position = aPosition;
            vTextureCoord = (gl_Position.xy + 1.0) * 0.5;
        }
    </string>
    <!-- Copy fragment shader -->
    <string name="shader_copy_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
        }
    </string>
    <!-- Displace fragment shader -->
    <string name="shader_displace_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec2 uPosition;
        uniform vec2 uDiff;
        varying vec2 vTextureCoord;
        
        void main() {
        	float c = 1.0 - sqrt(length(vTextureCoord - (uPosition - uDiff)));
            gl_FragColor = texture2D(sTexture0, vTextureCoord + c * uDiff);
        }
    </string>
    <!-- Input pass for bloom filter -->
    <string name="shader_bloom_pass1_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform float uThreshold;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            
            const vec3 perception = vec3(0.299, 0.587, 0.114);
            float luminance = dot(perception, gl_FragColor.rgb);
            luminance = (luminance - uThreshold) / (1.0 - uThreshold);
            gl_FragColor.a = clamp(luminance, 0.0, 1.0);
        }
    </string>
    <!-- Blur shader for bloom -->
    <string name="shader_bloom_pass2_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform vec2 uOffset;
        uniform float uSteps;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            vec2 offset = uOffset;
            gl_FragColor = vec4(0.0);
            for (float i = 0.0; i &lt; uSteps; ++i) {
                vec4 color0 = texture2D(sTexture0, vTextureCoord + offset);
                vec4 color1 = texture2D(sTexture0, vTextureCoord - offset);
                gl_FragColor.rgb += color0.rgb * color0.a;
                gl_FragColor.rgb += color1.rgb * color1.a;
                gl_FragColor.a += color0.a + color1.a;
                sum += 2.0;
                offset += uOffset;
            }
            gl_FragColor.rgb /= gl_FragColor.a;
            gl_FragColor.a /= sum;
        }
    </string>
    <!-- Output shader for bloom filter -->
    <string name="shader_bloom_pass3_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 color1 = texture2D(sTexture1, vTextureCoord);
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor.rgb += color1.rgb * color1.a;
        }
    </string>
    <!-- Input shader for lens blur filter -->
    <string name="shader_lensblur_pass1_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            const float minDivider = 1.0 / 255.0;
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor.a = mix(minDivider, 1.0, gl_FragColor.a);
            gl_FragColor.rgb *= gl_FragColor.a;
        }
    </string>
    <!-- Output shader for lens blur filter -->
    <string name="shader_lensblur_pass5_fs">
        precision mediump float;
        uniform sampler2D sTextureSrc;
        uniform sampler2D sTextureBokeh;
        uniform sampler2D sTextureBokehHdr;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 colSrc = texture2D(sTextureSrc, vTextureCoord);
            vec4 colBokeh = texture2D(sTextureBokeh, vTextureCoord);
            gl_FragColor = mix(colSrc, colBokeh, colBokeh.a);
            /*gl_FragColor.rgb += colBokehHdr.rgb * colBokehHdr.a;*/
        }
    </string>
    <!-- First blur pass for lens blur -->
    <string name="shader_lensblur_pass2_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord0 = vTextureCoord;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                if (sample0.a * uSteps >= t) {
                    float c = 1.0 - abs(sample0.a - coc);
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                textureCoord0 += uDelta0;
            }
            gl_FragColor /= sum;
        }
    </string>
    <!-- Second blur pass for lens blur -->
    <string name="shader_lensblur_pass3_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; ++t) {
                vec4 sample0 = texture2D(sTexture0, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    float c = 1.0 - abs(sample0.a - coc);
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor += texture2D(sTexture1, vTextureCoord - uDelta1 * 0.5);
            gl_FragColor *= 0.5;
        }
    </string>
    <!-- Third pass for lens blur filter -->
    <string name="shader_lensblur_pass4_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            vec2 textureCoord0 = vTextureCoord;
            vec2 textureCoord1 = vTextureCoord - uDelta0 * 0.5;
            float coc0 = texture2D(sTexture0, textureCoord0).a;
            float coc1 = texture2D(sTexture1, textureCoord1).a;
            gl_FragColor = vec4(0.0);
            for (float t = 0.0; t &lt;= uSteps; t++) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                vec4 sample1 = texture2D(sTexture1, textureCoord1);
                if (sample0.a * uSteps >= t) {
                    float c = 2.0 * (1.0 - abs(sample0.a - coc0));
                    gl_FragColor += sample0 * c;
                    sum += c;
                }
                if (sample1.a * uSteps >= t) {
                    float c = 1.0 - abs(sample1.a - coc1);
                    gl_FragColor += sample1 * c;
                    sum += c;
                }
                textureCoord0 += uDelta0;
                textureCoord1 += uDelta1;
            }
            gl_FragColor /= sum;
            gl_FragColor.rgb /= gl_FragColor.a;
        }
    </string>

</resources>