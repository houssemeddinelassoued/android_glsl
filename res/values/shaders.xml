<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="shader_scene_vs">
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        
        attribute vec4 aPosition;
        attribute vec4 aNormal;
        attribute vec4 aColor;
        
        varying vec4 vPos;
        varying vec4 vMvPos;
        varying vec4 vNormal;
        varying vec4 vColor;
               
        void main() {
            gl_Position = uMVPMatrix * vec4(aPosition.xyz, 1.0);
            vPos = gl_Position;
            vPos.xy *= 0.5;
            vMvPos = uMVMatrix * aPosition, 1.0;
            vMvPos.w = 0.0;
            vNormal = uNormalMatrix * aNormal;
            vNormal.w = 0.0;
            vNormal.xyz *= 1.0 / length(vNormal);
            vColor = aColor;
        }
    </string>
    <string name="shader_scene_fs">
        precision mediump float;
        uniform vec4 uLights[4];
        uniform int uLightCount;
        uniform float uCocScale;
        uniform float uCocBias;
        varying vec4 vPos;
        varying vec4 vMvPos;
        varying vec4 vNormal;
        varying vec4 vColor;
        
        vec2 calcLight(vec4 normal, vec4 lightDir, vec4 eyeVec) {
            vec2 lightVal = vec2(0.0);
            vec4 lightNormal = vec4(normalize(lightDir.xyz), 0.0);
            
            float lambert = dot(normal, lightNormal);
            if (lambert > 0.0) {
                float corr = inversesqrt(length(lightDir.xyz));
                lightVal[0] = lambert * corr;
                vec4 reflection = reflect(-lightNormal, normal);
                lightVal[1] = pow(max(dot(reflection, eyeVec), 0.0), 8.0) * corr;
            }
            return lightVal;
        }
        
        void main() {
            vec2 pos = (vPos.xy / vPos.w) + 0.5;
            
            vec2 lightVal = vec2(0.0);
            vec4 normal = normalize(vNormal);
            vec4 eyeVec = normalize(-vMvPos);
            if (uLightCount > 0)
                lightVal += calcLight(normal, uLights[0] - vMvPos, eyeVec);
            if (uLightCount > 1)
                lightVal += calcLight(normal, uLights[1] - vMvPos, eyeVec);
            if (uLightCount > 2)
                lightVal += calcLight(normal, uLights[2] - vMvPos, eyeVec);
            if (uLightCount > 3)
                lightVal += calcLight(normal, uLights[3] - vMvPos, eyeVec);
            
            const float ambient = 0.3;
            float ambientPlusDiffuse = min(ambient + lightVal[0], 1.0);
            float specular = min(lightVal[1], 1.0);
            
            const vec4 white = vec4(1.0);
            gl_FragColor = vColor * ambientPlusDiffuse;
            gl_FragColor = mix(gl_FragColor, white, specular);
            gl_FragColor.a = clamp(abs(gl_FragCoord.z * uCocScale + uCocBias), 0.0, 1.0);
            /* gl_FragColor.rgb = vec3(gl_FragColor.a); */
        }
    </string>
    <string name="shader_filter_vs">
        attribute vec4 aPosition;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_Position = aPosition;
            vTextureCoord = (gl_Position.xy + 1.0) * 0.5;
        }
    </string>
    <string name="shader_lensblur_in_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform float uCocScale;
        uniform float uCocBias;
        varying vec2 vTextureCoord;
        
        void main() {
            const float minDivider = 1.0 / 255.0;
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
            gl_FragColor.a = mix(minDivider, 1.0, gl_FragColor.a);
            gl_FragColor.rgb *= gl_FragColor.a;
        }
    </string>
    <string name="shader_lensblur_out_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        varying vec2 vTextureCoord;
        
        void main() {
            vec4 colSrc0 = texture2D(sTexture0, vTextureCoord);
            /*colSrc0.rgb /= colSrc0.a;*/
            vec4 colSrc1 = texture2D(sTexture1, vTextureCoord);
            gl_FragColor = mix(colSrc1, colSrc0, colSrc0.a);
            /*gl_FragColor.rgb = vec3(colSrc0.rgb);*/
        }
    </string>
    <string name="shader_lensblur_1_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0, step = 1.0 / uSteps;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            gl_FragColor = vec4(0.0);
            vec2 textureCoord0 = vTextureCoord;
            for (float t = 0.0; t &lt; 1.0 &amp;&amp; t &lt;= coc ; t += step) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                if (sample0.a >= coc || sample0.a >= t) {
                    gl_FragColor += sample0;
                }
                textureCoord0 += uDelta0;
                sum += 1.0;
            }
            gl_FragColor /= sum;
        }
    </string>
    <string name="shader_lensblur_2_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0, step = 1.0 / uSteps;
            float coc = texture2D(sTexture0, vTextureCoord).a;
            gl_FragColor = vec4(0.0);
            vec2 textureCoord0 = vTextureCoord;
            for (float t = 0.0; t &lt; 1.0 &amp;&amp; t &lt;= coc; t += step) {
                vec4 sample0 = texture2D(sTexture0, textureCoord0);
                if (sample0.a >= coc || sample0.a >= t) {
                    gl_FragColor += sample0;
                }
                textureCoord0 += uDelta0;
                sum += 1.0;
            }
            gl_FragColor /= sum;
            gl_FragColor = (gl_FragColor + texture2D(sTexture1, vTextureCoord)) * 0.5;
        }
    </string>
    <string name="shader_lensblur_3_fs">
        precision mediump float;
        uniform float uSteps;
        uniform sampler2D sTexture0;
        uniform sampler2D sTexture1;
        uniform vec2 uDelta0;
        uniform vec2 uDelta1;
        varying vec2 vTextureCoord;
        
        void main() {
            float sum = 0.0;
            gl_FragColor = vec4(0.0);
            vec2 textureCoord0 = vec2(vTextureCoord);
            vec2 textureCoord1 = vec2(vTextureCoord);
            for (float t = 0.0; t &lt; uSteps; t++) {
                gl_FragColor += texture2D(sTexture0, textureCoord0);
                gl_FragColor += texture2D(sTexture1, textureCoord1);
                textureCoord0 += uDelta0;
                textureCoord1 += uDelta1;
                sum += 2.0;
            }
            gl_FragColor /= sum;
            gl_FragColor.rgb /= gl_FragColor.a;
        }
    </string>
    <string name="shader_copy_fs">
        precision mediump float;
        uniform sampler2D sTexture0;
        varying vec2 vTextureCoord;
        
        void main() {
            gl_FragColor = texture2D(sTexture0, vTextureCoord);
        }
    </string>

</resources>